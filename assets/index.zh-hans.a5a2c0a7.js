export default"# 编写语法插件\n\n一般而言，如果我们想添加一个自定义语法插件，需要完成以下 5 个步骤：\n\n1. 添加一个 remark 插件来确保我们的语法可以正确的被解析和序列化。\n2. 为自定义语法添加一个 prosemirror schema。\n3. 编写一个解析器声明来将 remark AST 转换到 prosemirror 节点。\n4. 编写一个序列化器声明来将 prosemirror 节点转换到 remark AST。\n5. 编写一个 prosemirror 输入规则（input rule）来确保用户的输入可以被正确的转换为对应的 prosemirror 节点。\n\n---\n\n在这一节中，我们将添加一个**自定义 iframe 语法**来将 iframe 作为一种节点添加进 markdown。\n\n## Remark 插件\n\n首先，我们需要一个 remark 插件来支持我们的自定义语法。\n幸运的是，remark 提供了一个强大的 [directive 插件](https://github.com/remarkjs/remark-directive) 来支持自定义语法。通过这个插件，我们可以轻易的通过以下语法定义一个 iframe：\n\n```markdown\n# My Iframe\n\n:iframe{src=\"https://saul-mirone.github.io\"}\n```\n\n所以，我们需要的只是安装它并将其转换为一个 milkdown 插件：\n\n```typescript\nimport { remarkPluginFactory } from '@milkdown/core';\nimport directive from 'remark-directive';\n\nconst directiveRemarkPlugin = remarkPluginFactory(directive);\n```\n\n## 定义 Schema\n\n接着，我们需要定义 iframe 节点的 schema。\n我们把 iframe 定义为一个 inline 节点，因为它没有任何的子节点，\n并且有一个`src`标签来连接到目标页面。\n\n```typescript\nimport { nodeFactory } from '@milkdown/core';\n\nconst id = 'iframe';\nconst iframe = nodeFactory({\n    id,\n    schema: {\n        inline: true,\n        attrs: {\n            src: { default: null },\n        },\n        group: 'inline',\n        marks: '',\n        parseDOM: [\n            {\n                tag: 'iframe',\n                getAttrs: (dom) => {\n                    if (!(dom instanceof HTMLElement)) {\n                        throw new Error();\n                    }\n                    return {\n                        src: dom.getAttribute('src'),\n                    };\n                },\n            },\n        ],\n        toDOM: (node) => ['iframe', { ...node.attrs, class: 'iframe' }, 0],\n    },\n});\n```\n\n## 解析器\n\n接着，我们需要添加一个解析器声明，来将 remark AST 转换为 prosemirror node。\n你可以使用开发者工具去检查 remark AST 的结构。我们可以发现 iframe 具有以下结构：\n\n```typescript\nconst AST = {\n    name: 'iframe',\n    attributes: { src: 'https://saul-mirone.github.io' },\n    type: 'textDirective',\n};\n```\n\n所以我们可以轻易写出它对应的解析器声明：\n\n```typescript\nconst iframe = nodeFactory({\n    // ...\n    parser: {\n        match: (node) => node.type === 'textDirective' && node.name === 'iframe',\n        runner: (state, node, type) => {\n            state.addNode(type, { src: (node.attributes as { src: string }).src });\n        },\n    },\n});\n```\n\n现在，`defaultValue` 中的文本可以被正确的解析为 iframe 元素了。\n\n## 序列化器\n\n接着，我们需要添加序列化器来将 prosemirror 节点转回为 remark AST。\n\n```typescript\nconst iframe = nodeFactory({\n    // ...\n    serializer: {\n        match: (node) => node.type.name === id,\n        runner: (state, node) => {\n            state.addNode('textDirective', undefined, undefined, {\n                name: 'iframe',\n                attributes: {\n                    src: node.attrs.src,\n                },\n            });\n        },\n    },\n});\n```\n\n现在，iframe 元素可以被正确的序列化成 markdown 字符串了。\n\n## 输入规则\n\n我们也需要能够让用户的输入顺利转换为对应的 iframe。\n我们可以使用 `inputRules` 来定义 [prosemirror 用户输入](https://prosemirror.net/docs/ref/#inputrules) 来实现这个功能：\n\n```typescript\nimport { Node } from '@milkdown/core';\nimport { InputRule } from 'prosemirror-inputrules';\n\nconst iframe = nodeFactory({\n    // ...\n    inputRules: (nodeType) => [\n        new InputRule(/:iframe\\{src=\"(?<src>[^\"]+)?\"?\\}/, (state, match, start, end) => {\n            const [okay, src = ''] = match;\n            const { tr } = state;\n            if (okay) {\n                tr.replaceWith(start, end, nodeType.create({ src }));\n            }\n\n            return tr;\n        }),\n    ],\n});\n```\n\n## 使用插件\n\n最后，我们只需要使用 `use` 来使用我们编写的插件：\n\n```typescript\nimport { Editor } from '@milkdown/core';\nimport { commonmark } from '@milkdown/preset-commonmark';\n\nEditor.make().use([directiveRemarkPlugin, iframe]).use(commonmark).create();\n```\n\n---\n\n## 完整代码\n\n!CodeSandBox{milkdown-custom-syntax-mudgd?fontsize=14&hidenavigation=1&theme=dark&view=preview}\n";
