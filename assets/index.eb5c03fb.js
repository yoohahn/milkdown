export default"# Serializer\n\nSerializer is used to transform from UI elements to markdown string.\n\n## Transform Steps\n\nThe transformation steps are almost opposite to the steps in parser.\n\n1. For the current UI status, there will be a prosemirror node tree to represent it.\n2. The prosemirror node tree will be traversed by milkdown serializer. The milkdown serializer is generated by the serializer property of nodes and marks and generate a remark AST as the result.\n3. The remark AST will by transformed into markdown string through [remark-stringify](https://github.com/remarkjs/remark/tree/main/packages/remark-stringify).\n\n## Example\n\nFor every node, there will be a serializer specification which has the following structure:\n\n```typescript\nimport { nodeFactory } from '@milkdown/core';\n\nconst MyNode = nodeFactory({\n    // other props...\n    serializer = {\n        match: (node) => node.type.name === 'my-node',\n        runner: (state, node) => {\n            state.openNode('my-node').next(node.content).closeNode();\n        },\n    },\n});\n```\n\n## Serializer Specification\n\nThe serializer specification has 2 props:\n\n-   _match_: match the target prosemirror node that need to be handled by this runner.\n\n-   _runner_:\n\n    -   Node runner:\n        the function that transform the prosemirror node into remark AST, it has 2 parameters:\n\n        -   _state_: tools used to generate the remark AST.\n        -   _node_: the prosemirror node that need to be handled.\n\n    -   Mark runner:\n        the function that transform the prosemirror mark into remark AST, it has 3 parameters:\n\n        -   _state_: tools used to generate the remark AST.\n        -   _mark_: the prosemirror mark that need to be handled.\n        -   _node_: current mark's prosemirror node.\n\n        > If runner for mark return `true` instead of `undefined` or `null`,\n        > the mark's node will not be handled by serializer.\n\n## Serializer State\n\nThe serializer state is used to generate the remark AST,\nit provides several useful methods to make the transformation pretty simple.\n\n### openNode & closeNode\n\n`openNode` method will open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n\nYou can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n\nParameters:\n\n-   _type_: the type of the AST.\n-   _value_: the value of the remark AST.\n-   _props_: the properties of the AST.\n\nThe props will be spread, for example:\n\n```typescript\nopenNode('my-node', undefined, { foo: true, bar: 0 });\n// will generate:\nconst generatedCode = {\n    type: 'my-node',\n    foo: true,\n    bar: 0,\n    children: [\n        /* some children */\n    ],\n};\n```\n\n### addNode\n\n`addNode` means just add a node without open or close it. It's useful for nodes which don't have content.\n\nParameters:\n\n-   _type_: the type of the AST.\n-   _value_: the value of the remark AST.\n-   _props_: the properties of the AST.\n-   _children_: a markdown node list as the children of the AST.\n\n### next\n\n`next` give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n\n### withMark\n\n`withMark` is used when current node has marks, the serializer will auto combine marks nearby.\n\nParameters:\n\n-   _mark_: the mark of current node.\n-   _type_: the type of the AST.\n-   _value_: the value of the remark AST.\n-   _props_: the properties of the AST.\n";
