export default"# 编写自定义插件\n\n你也可以自己编写 Milkdown 插件而不使用提供的工具。通过这种方式，你将能够控制更多插件的细节。这有助于帮助你编写出更强大的插件。\n\n## 结构概览\n\n一般来说，一个插件具有如下结构：\n\n```typescript\nimport { MilkdownPlugin } from '@milkdown/core';\n\nconst myPlugin: MilkdownPlugin = (pre) => {\n    // #1 准备阶段\n    return async (ctx) => {\n        // #2 执行阶段\n    };\n};\n```\n\n每个插件由两部分组成：\n\n1. _准备_：这一阶段将在插件被通过 `use` 方法被注册进 milkdown 时执行。\n2. _执行_：这一阶段将在插件被真实加载时执行。\n\n## 定时器（Timer）\n\n定时器被用于决定当前插件被加载的时机，和当前插件将如何影响其它插件的加载。\n\n你可以使用 `ctx.wait` 来等待一个定时器结束。\n\n```typescript\nimport { MilkdownPlugin, Complete } from '@milkdown/core';\n\nconst myPlugin: MilkdownPlugin = () => {\n    return async (ctx) => {\n        const start = Date.now();\n\n        await ctx.wait(Complete);\n\n        const end = Date.now();\n\n        console.log('Milkdown load duration: ', end - start);\n    };\n};\n```\n\n你也可以创建自己的定时器，以及影响其它插件的加载时机。\n例如，让我创建一个插件，它将从远程服务器拉取编辑器的默认值。\n\n```typescript\nimport { MilkdownPlugin, editorStateTimerCtx, defaultValueCtx, createTimer } from '@milkdown/core';\n\nconst RemoteTimer = createTimer('RemoteTimer');\n\nconst remotePlugin: MilkdownPlugin = (pre) => {\n    pre.record(RemoteTimer);\n\n    return async (ctx) => {\n        ctx.update(editorStateTimerCtx, (timers) => timers.concat(RemoteTimer));\n\n        const defaultMarkdown = await fetchMarkdownAPI();\n        ctx.set(defaultValueCtx, defaultMarkdown);\n\n        ctx.done(RemoteTimer);\n    };\n};\n```\n\n它有如下几个步骤：\n\n1. 我们使用 `createTimer` 来创建定时器，然后使用 `pre.record` 来将定时器注册到 milkdown 中。\n2. 我们更新 `editorStateTimerCtx` 来告诉内置的 `editorState` 插件，它应该等我们 的远程获取步骤结束后再执行。\n3. 当我们从 `fetchMarkdownAPI`中取到需要的数据后，我们将它设置为 `defaultValue` 并调用 `ctx.done` 来将定时器标记为结束。\n\n## 上下文（Ctx）\n\n在上个例子中，我们已经使用了 `ctx` 许多次了，现在让我们尝试去理解它是什么。\n上下文是一个可以在整个编辑器实例中共享的数据切片。\n\n```typescript\nimport { MilkdownPlugin, createCtx } from '@milkdown/core';\n\nconst counterCtx = createCtx(0);\n\nconst counterPlugin: MilkdownPlugin = (pre) => {\n    pre.inject(counterCtx);\n\n    return (ctx) => {\n        // count is 0\n        const count0 = ctx.get(counterCtx);\n\n        // set count to 1\n        ctx.get(counterCtx, 1);\n\n        // now count is 1\n        const count1 = ctx.get(counterCtx);\n\n        // set count to n + 2\n        ctx.update(counterCtx, (prev) => prev + 2);\n\n        // now count is 3\n        const count2 = ctx.get(counterCtx);\n    };\n};\n```\n\n我们可以使用 `createCtx` 来创建上下文，然后使用 `pre.inject` 来将其注册到编辑器中。`ctx.get` 来获取一个上下文的值，使用 `ctx.set` 来设置它的值，或是使用 `ctx.update` 来使用一个回调函数更新上下文。\n\n所以当我们结合 `timer` 使用 `ctx` 时，我们可以决定一个插件执行的时机。\n\n```typescript\nimport { MilkdownPlugin, SchemaReady, Timer, createCtx } from '@milkdown/core';\n\nconst examplePluginTimersCtx = createCtx<Timer[]>([]);\n\nconst examplePlugin: MilkdownPlugin = (pre) => {\n    pre.inject(counterCtx, [SchemaReady]);\n    return async (ctx) => {\n        await Promise.all(ctx.get(examplePluginTimersCtx).map((timer) => ctx.wait(timer)));\n        // 或者我们也可以用一个内置的语法糖简化它\n        await ctx.waitTimers(examplePluginTimersCtx);\n\n        // do something\n    };\n};\n```\n\n通过这种模式，如果其它插件想要延迟 `examplePlugin` 的执行，它们需要做的就是通过 `ctx.update` 添加一个定时器到 `examplePluginTimerCtx` 中。\n";
